# Oracle PL/SQL 代码结构解析器技术设计文档

## 1. 节点对象定义

一个节点对象包含如下元素：
1. 类型：函数或过程
2. 名称
3. 声明行行号
4. BEGIN 行行号
5. EXCEPTION 行行号 (可为NULL，默认为NULL)
6. END 行行号
7. 层级
8. 子节点数组：存储当前节点的所有子函数/过程

## 2. 全局变量定义

1. 层级的全局变量
2. BEGIN_END_COUNTER
3. 节点栈：用于管理父子节点关系
4. 当前活动节点指针：指向正在处理的节点
5. 根节点集合：存储所有顶层节点

## 3. 解析流程

### 3.1 初始化处理

在开始解析前，初始化所有全局变量：节点栈清空、当前活动节点设为NULL、层级全局变量设为0、BEGIN_END_COUNTER设为0、根节点集合清空。

### 3.2 预处理步骤

逐行读取代码文件时，先进行预处理：
- 去除行首尾空白字符
- 跳过空行和注释行（以--开头或/**/包围的行）
- 使用正则表达式进行精确的关键字匹配，避免误识别字符串中的关键字

### 3.3 CREATE OR REPLACE 处理

如果为CREATE OR REPLACE FUNCTION/PROCEDURE 行，读取函数/过程名作为顶层节点。创建节点对象并赋值类型、名称、声明行行号、层级=1。层级的全局变量设为1。将该节点设为当前活动节点，并添加到根节点集合中。

### 3.4 继续读取代码文件处理

#### 3.4.1 BEGIN关键字处理

如果接下来读取到BEGIN关键字，说明声明部分结束，赋值BEGIN 行行号，BEGIN_END_COUNTER=1。

3.4.1.1 继续逐行读取，如果接下来再读取到BEGIN关键字，BEGIN_END_COUNTER = BEGIN_END_COUNTER + 1。判断 BEGIN_END_COUNTER 是否等于1，如果不等于1则不解析其他关键字。

3.4.1.2 读取到EXCEPTION关键字时，判断BEGIN_END_COUNTER 是否等于1，如果不等于1则不解析。如果等于1则记录当前活动节点的EXCEPTION 行行号。

3.4.1.3 读取到END关键字，BEGIN_END_COUNTER = BEGIN_END_COUNTER - 1并判断 BEGIN_END_COUNTER 是否等于0，如果不等于0则不解析。如果等于0则记录END 行行号。完成后将层级的全局变量设为层级的全局变量-1。从节点栈中弹出父节点，将当前活动节点指针设置为父节点（如果栈为空则设为NULL）。

#### 3.4.2 子函数/过程处理

如果接下来读取到的是FUNCTION/PROCEDURE关键字，则说明当前的函数/过程是子函数/子过程。执行如下动作：

3.4.2.1 创建新的节点对象，并赋值类型、名称、声明行行号。将当前活动节点压入节点栈，将当前活动节点的子节点数组中添加新节点，然后将"当前活动节点"设置为新建的节点对象。

3.4.2.2 层级的全局变量 = 层级的全局变量 + 1。并将计算后的层级的全局变量赋值为当前节点对象的层级。重置BEGIN_END_COUNTER=0。

3.4.2.3 继续读取代码，如果读取到BEGIN，则重复3.4.1.1~3.4.1.3的动作。

3.4.2.4 如果又读到FUNCTION/PROCEDURE关键字，则重复3.4.2.1~3.4.2.3的动作。

### 3.5 错误处理和边界条件

3.5.1 语法容错处理：遇到不规范的代码结构时，记录错误但继续解析后续内容。

3.5.2 嵌套深度限制：设置合理的嵌套深度上限，防止无限递归。

3.5.3 文件结束处理：文件读取完毕后，检查是否还有未完成的节点，进行适当的收尾处理。

## 4. 关键字匹配规则

按需处理

## 5. 输出结果

解析完成后，返回根节点集合，其中每个根节点包含完整的层次结构，子节点通过子节点数组形式组织，形成树状结构。每个节点都包含完整的位置信息（声明行、BEGIN行、EXCEPTION行、END行）和层级信息。